%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[review]{elsarticle}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}


\usepackage{cmap}

\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}






\usepackage[,numfigreset=2,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{System identification of Vessel Manoeuvring Models}
\date{May 16, 2022}
\release{}
\author{Martin Alexandersson}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}
\input{front}


\pagestyle{empty}

\pagestyle{plain}

\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\section{Introduction}
\label{\detokenize{00.02_introduction:introduction}}\label{\detokenize{00.02_introduction::doc}}
\sphinxAtStartPar
The manoeuvring performance of ships can be assessed in many ways, where model test with a free moving model is the most established and accurate method to confirm the compliance with the IMO standards. Going beyond the results from a model test campaign, looking at alternative scenarios with other speeds or entirely other manoeuvres or even bridge simulations, a prediction model is needed. The prediction model is usually developed with system identification.
System identification aims at identifying a system from observations. If a parameterized model is further assumed, Parameter Identification Technique (PIT) can be applied. The system identification uses a PIT to identify the hydrodynamic derivatives (parameters) in a VMM. The VMM:s solves the equation of motion and models the hydrodynamic forces.
The classical VMM:s (Abkowitz, 1964), (Clarke et al., 1982), (Nomoto et al., 1957) express the hydrodynamic forces as a function of the current state expressed as polynomials where the coefficients are called hydrodynamic derivatives. Most of the VMM:s where developed many year ago but there is also more recent development as the MMG model (Yasukawa and Yoshimura, 2015).


\subsection{Objective/Goal}
\label{\detokenize{00.02_introduction:objective-goal}}
\sphinxAtStartPar
A system for ship manoeuvring should be identified based on model test data recorded as ship trajectories (position and heading) from manoeuvring model tests with a ship model free in all degrees of freedoms. The system is further assumed to be described by a Vessel Manoeuvring Model (VMM). The System identification can then be simplified into parameter identification of the assumed model. A Parameter Identification Technique (PIT) for this purpose is presented in this paper.


\subsection{Outline}
\label{\detokenize{00.02_introduction:outline}}
\sphinxAtStartPar
The PIT algorithm is introduced in section 2 where each subcomponent is also described in detailed subsections. Section 3 shows how the PIT is applied on three test cases and all conclusions can be found in section 4.


\section{Method}
\label{\detokenize{01.01_method:method}}\label{\detokenize{01.01_method::doc}}

\subsection{Overview}
\label{\detokenize{01.01_method:overview}}

\subsubsection{VMM}
\label{\detokenize{01.01_method:vmm}}
\sphinxAtStartPar
The VMM (see section  {\hyperref[\detokenize{02.01_VMMs:vmm}]{\sphinxcrossref{\DUrole{std,std-ref}{VMM}}}} ) expresses the dynamics of a ship. This ability is most often used to conduct manoeuvring simulations, where a VMM with known forces from hydrodynamic derivatives is used to predict unknown ship manoeuvres.


\subsubsection{Inverse dynamics}
\label{\detokenize{01.01_method:inverse-dynamics}}
\sphinxAtStartPar
VMM can also be used to solve the reversed problem: predicting unknown forces from known ship manoeuvres, which is applicable for the current problem. This is called inverse dynamics (see section {\hyperref[\detokenize{03.01_inverse_dynamics:inverse-dynamics}]{\sphinxcrossref{\DUrole{std,std-ref}{Inverse\sphinxhyphen{}dynamics}}}}).


\subsubsection{Regression}
\label{\detokenize{01.01_method:regression}}
\sphinxAtStartPar
The hydrodynamic derivatives in the VMM can be identified with regression of the force polynomials on forces predicted with inverse dynamics, which is called ‘’motion regression’’ in this paper. Many authors have used different statistical methods or machine learning methods to regress the hydrodynamic derivatives. The Linear regression with Ordinary Least Square fit (OLS) is used in the proposed PIT. The OLS is known to be sensitive to noise and outliers, which is why the main focus in the present PIT is on pre\sphinxhyphen{}processing data with filtering rather than the regression method itself.


\subsubsection{EKF}
\label{\detokenize{01.01_method:ekf}}
\sphinxAtStartPar
The filtering in the PIT is conducted with an Extended Kalman Filter (EKF) (see section {\hyperref[\detokenize{04.01_EK:ekf}]{\sphinxcrossref{\DUrole{std,std-ref}{EKF}}}}) which is a recursive filter that estimates the state of a linear or nonlinear dynamic system from a series of noisy measurements. The basic idea is that noise can be disregarded if it does not make sense from a physical point of view. If noisy measurement data would be perfectly correct, this would mean that the ship has a lot of vibrations that must have originated from huge forces, considering the large mass of the ship. The prior understanding of the model tests data suggests that these huge forces are not present during the model test, and the noise is therefore considered as measurement noise that should be removed. Lowpass filtering is a common way to do this, where motions above some cut\sphinxhyphen{}off frequency are regarded as unphysical measurement noise. The problem with lowpass filter is that it is hard to know what the cut\sphinxhyphen{}off frequency to choose, either too low: removing part of the signal, or too high: keeping some unfiltered measurement noise in the data.
The Kalman filter has a system model that continuously estimates the state of the system that is run in parallel with the measurement data. The filter estimates the current state as a combination of the measurement data and the system model estimate based on belief in the data and the model. If the data has low noise the estimate turns towards that data, if on the other hand the model gives very good predictions that estimate turns towards the model. The inverse dynamics requires the entire state of the system to be known including: positions, velocities and accelerations. Only positions are known from the measurements which means that velocities and accelerations are hidden states that can be estimated by EKF.


\subsubsection{RTS}
\label{\detokenize{01.01_method:rts}}
\sphinxAtStartPar
The EKF is recursive and can be run online, continuously making new estimates as new measurements arrive. It uses passed measurements to estimate states in the near future. This is useful for applications like autopilots. For the PIT the filter is instead run on a whole time series of existing measurements. The fact that both past and future data is known can be used to improve the filter by attaching a smoother after the EKF.  The PIT uses a Rauch Tung Striebel (RTS) smoother (see section {\hyperref[\detokenize{04.01_EK:rts}]{\sphinxcrossref{\DUrole{std,std-ref}{RTS}}}}).

\sphinxAtStartPar
{\hyperref[\detokenize{01.01_method:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{Fig}}}} shows a flow chart summarizing how the PIT works. A VMM is used as the system model in the EKF. But the identified VMM is of course not known yet which is a ‘’the chicken or the egg’’ situation. This is solved with initial guessing and iteration.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{method}.png}
\caption{Flow chart over the proposed Parameter Identification Technique (PIT)}\label{\detokenize{01.01_method:id1}}\end{figure}


\subsubsection{Step 1)}
\label{\detokenize{01.01_method:step-1}}
\sphinxAtStartPar
VMM with guessed hydrodynamic derivatives is used. To make a fair guess, the derivatives are estimated with semiempirical formulas for a linear VMM. The VMM is used in the EKF and RTS smoother to filter all the model tests. The VMM:s are assumed to have Markov property which means that future states depend only on the current state. This means that the filtered data with estimated hidden states from all the model tests can be joined into one time independent dataset that is passed to the motion regression. The hydrodynamic derivatives are regressed on quasi static forces from inverse dynamics giving the identified nonlinear VMM.


\subsubsection{Step 2)}
\label{\detokenize{01.01_method:step-2}}
\sphinxAtStartPar
Step1 can now be rerun, but instead of using the guessed system model, the identified VMM from step 1 can now be used in the EKF. There should be a higher belief in this model than the guessed model, so the covariance matrixes should be updated.


\subsection{Vessel Manoeuvring Models}
\label{\detokenize{02.01_VMMs:vessel-manoeuvring-models}}\label{\detokenize{02.01_VMMs::doc}}
\sphinxAtStartPar
Many simulation model for ship manoeuvring have been developed in the field of ship hydrodynamics such as: the Abkowitz model {[}\hyperlink{cite.bibligraphy:id139}{Abk64}{]} or the Norrbin model {[}\hyperlink{cite.bibligraphy:id126}{Nor60}{]}.
This chapter will develop a general simulation model for ship manoeuvring, that can be further specified to become either the Abkowitz or Norbin model.

\sphinxAtStartPar
The vessel manoeuvring models can be expressed in a very general way ( {[}\hyperlink{cite.bibligraphy:id167}{Fos21}{]}):

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Where \(\eta\) describes the position:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
and \(\nu\) is the velocities:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
The accelerations are denoted using the dotted notation: \(\dot{\nu}\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(M\) is inertia matrix

\item {} 
\sphinxAtStartPar
\(C(\nu)\) is corriolis/centrepetal matrix as function of the velocities \textbackslash{}nu.

\item {} 
\sphinxAtStartPar
\(D(\nu)\) is damping matrix as a function of vecocities \textbackslash{}nu.

\item {} 
\sphinxAtStartPar
\(g(\eta)\) is a vector of generalized gravitational an buoyance forces.

\item {} 
\sphinxAtStartPar
\(g_0\) is static restoring forces due to ballast systems.

\item {} 
\sphinxAtStartPar
\(\tau\) is vector of control inputs (from rudders/propellers etc.)

\item {} 
\sphinxAtStartPar
\(\tau_{wind}\) is vector of wind forces

\item {} 
\sphinxAtStartPar
\(\tau_{wave}\) is vector of wave forces

\end{itemize}

\sphinxAtStartPar
The velocities can also include the ocean current by expressing the relative velocity \(v_r\) as:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \nu_{r} = \nu - \nu_{c}\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
If the current is assumed to be irrotational, the angular velocities for the current is zero:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \nu_{c} = \left[\begin{matrix}u_{c}\\v_{c}\\w_{c}\\0\\0\\0\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \nu_{r} = \left[\begin{matrix}u - u_{c}\\v - v_{c}\\w - w_{c}\\p\\q\\r\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
If the current is also assumed to be constant, this mean that the time derivative of \(\nu\) and \(\nu_r\) are the same, also giving the same accelerations:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \dot{\nu_r} = \dot{\nu}\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
When current is present the inertia as well as the corriolis matrix must be split into an added mass part (A) and a rigid body part (RB):

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle M = M_{A} + M_{RB}\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle C = C_{A} + C_{RB}\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
So that the model equation can be written as:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle C_{A} \nu_{r} + C_{RB} \nu + D \nu_{r} + M_{A} \dot{\nu} + M_{RB} \dot{\nu} + g_{0} + g{\left(\eta \right)} = \tau + \tau_{wave} + \tau_{wind}\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
This equation can be simplified for manoeuvring models by firstly only keeping surge, sway and yaw degrees of freedome. This means that both \(g_0\) and \(g(\eta)\) dissapears as there are no static forces for surge, sway and yaw. For the classic manoeuvring problem also forces from wind and waves are neglected, removing \(\tau_{wave}\) and \(\tau_{wind}\). In this paper, there are no ocean current during the studied model tests, so that the relative velocity \(v_r\) can be replaced with \(v\).

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle C_{A} \nu + C_{RB} \nu + D \nu + M_{A} \dot{\nu} + M_{RB} \dot{\nu} = \tau\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
And these matrices can be expressed in 3 degrees of freeddome ( {[}\hyperlink{cite.bibligraphy:id167}{Fos21}{]}):

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle C_{A} = \left[\begin{matrix}0 & 0 & Y_{\dot{r}} r + Y_{\dot{v}} v\\0 & 0 & - X_{\dot{u}} u\\- Y_{\dot{r}} - Y_{\dot{v}} v & X_{\dot{u}} u & 0\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle C_{RB} = \left[\begin{matrix}0 & - m r & - m r x_{G}\\m r & 0 & 0\\m r x_{G} & 0 & 0\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle M_{A} = \left[\begin{matrix}- X_{\dot{u}} & 0 & 0\\0 & - Y_{\dot{v}} & - Y_{\dot{r}}\\0 & - N_{\dot{v}} & - N_{\dot{r}}\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle M_{RB} = \left[\begin{matrix}m & 0 & 0\\0 & m & m x_{G}\\0 & m x_{G} & I_{z}\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
The damping and control inputs from rudders and propellers are replaced with the functions \(X_D(u,v,r,\delta,thrust)\), \(Y_D(u,v,r,\delta,thrust)\), \(N_D(u,v,r,\delta,thrust)\). Note that the measured thrust from the model tests is used as input to the models, which means that the propeller is not part of the models in this paper. Main focus is thereby on the modelling of rudder and hull forces.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \tau - D{\left(\nu \right)} = \left[\begin{matrix}\operatorname{X_{D}}{\left(u,v,r,\delta,thrust \right)}\\\operatorname{Y_{D}}{\left(u,v,r,\delta,thrust \right)}\\\operatorname{N_{D}}{\left(u,v,r,\delta,thrust \right)}\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
The system equation can now be written as:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \left[\begin{matrix}- X_{\dot{u}} + m & 0 & 0\\0 & - Y_{\dot{v}} + m & - Y_{\dot{r}} + m x_{G}\\0 & - N_{\dot{v}} + m x_{G} & I_{z} - N_{\dot{r}}\end{matrix}\right] \left[\begin{matrix}\dot{u}\\\dot{v}\\\dot{r}\end{matrix}\right] = \left[\begin{matrix}m r^{2} x_{G} + m r v + \operatorname{X_{D}}{\left(u,v,r,\delta,thrust \right)}\\- m r u + \operatorname{Y_{D}}{\left(u,v,r,\delta,thrust \right)}\\- m r u x_{G} + \operatorname{N_{D}}{\left(u,v,r,\delta,thrust \right)}\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
This equation can be rewritten to get the acceleration on the left hand side:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \dot{\nu} = \left[\begin{matrix}\dot{u}\\\dot{v}\\\dot{r}\end{matrix}\right] = \left[\begin{matrix}\frac{1}{- X_{\dot{u}} + m} & 0 & 0\\0 & - \frac{- I_{z} + N_{\dot{r}}}{S} & - \frac{- Y_{\dot{r}} + m x_{G}}{S}\\0 & - \frac{- N_{\dot{v}} + m x_{G}}{S} & - \frac{Y_{\dot{v}} - m}{S}\end{matrix}\right] \left[\begin{matrix}m r^{2} x_{G} + m r v + \operatorname{X_{D}}{\left(u,v,r,\delta,thrust \right)}\\- m r u + \operatorname{Y_{D}}{\left(u,v,r,\delta,thrust \right)}\\- m r u x_{G} + \operatorname{N_{D}}{\left(u,v,r,\delta,thrust \right)}\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
where \(S\) is a helper variable:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle S = - I_{z} Y_{\dot{v}} + I_{z} m + N_{\dot{r}} Y_{\dot{v}} - N_{\dot{r}} m - N_{\dot{v}} Y_{\dot{r}} + N_{\dot{v}} m x_{G} + Y_{\dot{r}} m x_{G} - m^{2} x_{G}^{2}\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
A state space model for manoeuvring can now be defined with six states:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \vec{x} = \left[\begin{matrix}x_{0}\\y_{0}\\\Psi\\u\\v\\r\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
An transition function \(f\) defines how the states changes with time:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle \dot{\vec{x}} = f{\left(\vec{x},u_{input},w_{noise} \right)}\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Using geometrical relations for how \(x_0\), \(y_0\) and \(\Psi\) depend on \(u\), \(v\), and \(r\) and the time derivatives that was derived above: \(\dot{u}\), \(\dot{v}\), \(\dot{r}\), the transition function can be written:

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove-input}
\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\displaystyle f{\left(\vec{x},u_{input},w_{noise} \right)} = \left[\begin{matrix}u \cos{\left(\Psi \right)} - v \sin{\left(\Psi \right)}\\u \sin{\left(\Psi \right)} + v \cos{\left(\Psi \right)}\\r\\\dot{u}\\\dot{v}\\\dot{r}\end{matrix}\right]\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
The manoeuvring simulation can now be conducted by numerical integration of the above equation. The main difference between various vessel manoeuvring models such as the Abkowitz model {[}\hyperlink{cite.bibligraphy:id139}{Abk64}{]} or the Norrbin model {[}\hyperlink{cite.bibligraphy:id126}{Nor60}{]} lies in how the hydrodynamic functions \(X_D(u,v,r,\delta,thrust)\), \(Y_D(u,v,r,\delta,thrust)\), \(N_D(u,v,r,\delta,thrust)\) are defined. These functions cane be found in {\hyperref[\detokenize{appendix_vmms::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Appendix}}}}.

\sphinxAtStartPar
Note! Thrust dependent coefficients have been added to the abkowitz model: \(X_{thrust}\), \(Y_{thrust}\), \(N_{thrust}\) to allow for propeller thrust as an input to the model.


\subsection{Inverse dynamics}
\label{\detokenize{03.01_inverse_dynamics:id1}}\label{\detokenize{03.01_inverse_dynamics::doc}}
\sphinxAtStartPar
Each manoeuvring model has some hydrodynamic functions \(X_D(u,v,r,\delta,thrust)\), \(Y_D(u,v,r,\delta,thrust)\), \(N_D(u,v,r,\delta,thrust)\) that are defined as polynomials.

\sphinxAtStartPar
The hydrodynamic derivatives in these polynomials can be identified with force regression of measured forces and moments. The measured forces and moments are usually taken from captive model tests, PMM tests or Virtual Captive Tests (VCT) being the virtual version of captive/PMM tests calculated with Computational Fluid Dynamics (CFD).

\sphinxAtStartPar
When the ship or ship model is free in all degrees of freedome, as in the present model tests, only motions can be observed however. The forces and moments that generated the motions needs to be estimated by solving the inverse dynamics problem and doing a motion regression.

\sphinxAtStartPar
The inverse dynamics is solved by restructering the system equation {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqsystem}]{\sphinxcrossref{(2.1)}}} to get the hydrodynamics functions on the left hand side {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqxd}]{\sphinxcrossref{(2.2)}}}, {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqyd}]{\sphinxcrossref{(2.3)}}}, {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqnd}]{\sphinxcrossref{(2.4)}}}. If the mass and intertia of the ship as well as added masses: \(\dot{u}\), \(\dot{v}\), \(\dot{r}\) are known, the forces can be calculated using these equations.
\begin{equation}\label{equation:03.01_inverse_dynamics:eqsystem}
\begin{split}\displaystyle \left[\begin{matrix}- X_{\dot{u}} + m & 0 & 0\\0 & - Y_{\dot{v}} + m & - Y_{\dot{r}} + m x_{G}\\0 & - N_{\dot{v}} + m x_{G} & I_{z} - N_{\dot{r}}\end{matrix}\right] \left[\begin{matrix}\dot{u}\\\dot{v}\\\dot{r}\end{matrix}\right] = \left[\begin{matrix}m r^{2} x_{G} + m r v + \operatorname{X_{D}}{\left(u,v,r,\delta,thrust \right)}\\- m r u + \operatorname{Y_{D}}{\left(u,v,r,\delta,thrust \right)}\\- m r u x_{G} + \operatorname{N_{D}}{\left(u,v,r,\delta,thrust \right)}\end{matrix}\right]\end{split}
\end{equation}\begin{equation}\label{equation:03.01_inverse_dynamics:eqxd}
\begin{split}\displaystyle \operatorname{X_{D}}{\left(u,v,r,\delta,thrust \right)} = - X_{\dot{u}} \dot{u} + \dot{u} m - m r^{2} x_{G} - m r v\end{split}
\end{equation}\begin{equation}\label{equation:03.01_inverse_dynamics:eqyd}
\begin{split}\displaystyle \operatorname{Y_{D}}{\left(u,v,r,\delta,thrust \right)} = - Y_{\dot{r}} \dot{r} - Y_{\dot{v}} \dot{v} + \dot{r} m x_{G} + \dot{v} m + m r u\end{split}
\end{equation}\begin{equation}\label{equation:03.01_inverse_dynamics:eqnd}
\begin{split}\displaystyle \operatorname{N_{D}}{\left(u,v,r,\delta,thrust \right)} = I_{z} \dot{r} - N_{\dot{r}} \dot{r} - N_{\dot{v}} \dot{v} + \dot{v} m x_{G} + m r u x_{G}\end{split}
\end{equation}
\sphinxAtStartPar
An example of forces calculated with inverse dynamics from motions in a turning circle test can be seen in {\hyperref[\detokenize{03.01_inverse_dynamics:fig-inverse}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_remove_input}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2702fdee558cd434af85eb7b4eed19c8ddc5840545a6f0f76c562e9c2d6b4c78}.png}
\caption{Example of forces and moments calculated with inverse dynamics on data from a turning circle test.}\label{\detokenize{03.01_inverse_dynamics:fig-inverse}}\end{figure}


\subsection{Regression}
\label{\detokenize{03.01_inverse_dynamics:regression}}
\sphinxAtStartPar
Finding the the hydrodynamic derivatives can be defined as a linear regression problem:
\begin{equation}\label{equation:03.01_inverse_dynamics:eqregression}
\begin{split}y = X\beta + \epsilon\end{split}
\end{equation}
\sphinxAtStartPar
A model for the hydrodynamic forces first needs to be assumed for instance as the polynomials in: {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqxqsmodel}]{\sphinxcrossref{(3.2)}}}, {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqyqsmodel}]{\sphinxcrossref{(3.3)}}} and {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqnqsmodel}]{\sphinxcrossref{(3.4)}}}.
\begin{equation}\label{equation:03.01_inverse_dynamics:eqxqsmodel}
\begin{split}\displaystyle \operatorname{X_{D}}{\left(u,v,r,\delta,thrust \right)} = X_{deltadelta} \delta^{2} + X_{rr} r^{2} + X_{thrust} thrust + X_{u} u + X_{vr} r v\end{split}
\end{equation}\begin{equation}\label{equation:03.01_inverse_dynamics:eqyqsmodel}
\begin{split}\displaystyle \operatorname{Y_{D}}{\left(u,v,r,\delta,thrust \right)} = Y_{delta} \delta + Y_{r} r + Y_{thrustdelta} \delta thrust + Y_{ur} r u + Y_{u} u + Y_{v} v\end{split}
\end{equation}\begin{equation}\label{equation:03.01_inverse_dynamics:eqnqsmodel}
\begin{split}\displaystyle \operatorname{N_{D}}{\left(u,v,r,\delta,thrust \right)} = N_{delta} \delta + N_{r} r + N_{thrustdelta} \delta thrust + N_{ur} r u + N_{u} u + N_{v} v\end{split}
\end{equation}
\sphinxAtStartPar
The label vector \(y\) and feature matrix \(X\) in the regression problem in {\hyperref[\detokenize{03.01_inverse_dynamics:equation-eqregression}]{\sphinxcrossref{(3.1)}}} can now be inserted. As an example the regression in surge degree of freedome the labels can be calculated using the inverse dynamics force:
\begin{equation}\label{equation:03.01_inverse_dynamics:diff_eq_X_y}
\begin{split}\displaystyle y = - X_{\dot{u}} \dot{u} + \dot{u} m - m r^{2} x_{G} - m r v\end{split}
\end{equation}
\sphinxAtStartPar
And the feature matrix \(X\) is expressed as:
\begin{equation}\label{equation:03.01_inverse_dynamics:diff_eq_X_X}
\begin{split}\displaystyle X = \left[\begin{matrix}thrust & u & \delta^{2} & r^{2} & r v\end{matrix}\right]\end{split}
\end{equation}
\sphinxAtStartPar
And the regressed hydrodynamic derivatives are stored in the \(\beta\) vector:
\begin{equation}\label{equation:03.01_inverse_dynamics:diff_eq_X_beta}
\begin{split}\displaystyle \beta = \left[\begin{matrix}X_{thrust}\\X_{u}\\X_{deltadelta}\\X_{rr}\\X_{vr}\end{matrix}\right]\end{split}
\end{equation}
\sphinxAtStartPar
Solving the regressions with OLS in each degree of freedome gives a perfect match of hydrodynamic derivatives compared to the real model used when generating the simulated data as seen in {\hyperref[\detokenize{03.01_inverse_dynamics:fig-bar-parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}. Parameter identification using linear regression with forces calculated with inverse dynamics with a model that is perfectly correct on data that is also perfect will obviously give a perfect identification of the system.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{8be84f63d298ae0d5a5c635c248d145bd829d84a813cc9b5eed153e353ace468}.png}
\caption{Real and regressed parameters}\label{\detokenize{03.01_inverse_dynamics:fig-bar-parameters}}\end{figure}


\subsection{Extended Kalman Filter}
\label{\detokenize{04.01_EK:extended-kalman-filter}}\label{\detokenize{04.01_EK::doc}}
\sphinxAtStartPar
It has been shown that it is possible to do parameter identification on perfect (simulated) data with no noise. Such data from physical experiments does not exist in reality however. The measured data will always contain process noise and measurement noise. In order to mitigate this the data is preprocessed using an Extended Kalman filter (EKF). EKF is extending the Kalman Filter (KF) to work on nonlinear systems such as as the VMM:s.

\sphinxAtStartPar
The nonlinear system (the ship) is expressed with a transition model \(f(x,u)\) and process noise \(w\). \(x\) is the current state and \(u\) are control inputs (rudder angle and thrust). A VMM is used as the transition model for the model test data EKF.
\begin{equation}\label{equation:04.01_EK:eqnonlinearsystem}
\begin{split}\dot{x} = f(x,u) + w\end{split}
\end{equation}
\sphinxAtStartPar
The state of the system is observed (measured) with the linear observation model \(H\) and measurement noise \(v\).
\begin{equation}\label{equation:04.01_EK:eqobserve}
\begin{split}y = Hx + v\end{split}
\end{equation}
\sphinxAtStartPar
The used EKF recursive algorithm used is summarized in pseudocode below.
\label{04.01_EK:ek-algorithm}
\begin{sphinxadmonition}{note}{Algorithm 4.1 (Discrete\sphinxhyphen{}time extended Kalman filter)}



\sphinxAtStartPar
\sphinxstylestrong{Inputs} Initial values: \(x_0\), \(P_0\), \(C_d\), \(R_d\), \(Q_d\), \(E_d\)

\sphinxAtStartPar
\sphinxstylestrong{Output} Estimated states: \(\hat{x}\), estimated state covariances \(\hat{P}\)
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Initial values:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
\(\hat{x}[0] = x_0\)

\item {} 
\sphinxAtStartPar
\(\hat{P}[0] = P_0\)

\end{enumerate}

\item {} 
\sphinxAtStartPar
For \(k\) in \(n\) measurements
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
KF gain
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumiii}{enumiv}{}{.}%
\item {} 
\sphinxAtStartPar
\(K[k]=\hat{P}[k] C_d^T \left(C_d \hat{P}[k] C_d^T + R_d\right)^{-1}\)

\item {} 
\sphinxAtStartPar
\(I_{KC} = I_n - K[k] C_d\)

\end{enumerate}

\item {} 
\sphinxAtStartPar
Update
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumiii}{enumiv}{}{.}%
\item {} 
\sphinxAtStartPar
State corrector
\(\hat{x}[k] = \hat{x}[k] + K[k] (y - C_d \hat{x}[k]) \)

\item {} 
\sphinxAtStartPar
Covariance corrector
\(\hat{P}[k] = I_{KC} \cdot \hat{P}[k] I_{KC}^T + K[k] R_d K^T \)

\end{enumerate}

\item {} 
\sphinxAtStartPar
Predict
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumiii}{enumiv}{}{.}%
\item {} 
\sphinxAtStartPar
State predictor
\(\hat{x}[k+1] = \hat{x}[k] + h \cdot \hat{f}(\hat{x}[k], u[k])\)

\item {} 
\sphinxAtStartPar
Covariance predictor
\(\hat{P}[k+1] = A_d[k]  \hat{P}[k] A_d[k]^T + E_d Q_d E_d^T \)

\end{enumerate}

\end{enumerate}

\end{enumerate}
\end{sphinxadmonition}

\sphinxAtStartPar
Where \(n\) is number of states (6 in this case), \(I_n\) is an \(n\) * \(n\) identity matrix.

\sphinxAtStartPar
The transition matrix is calculated for each iteration using a Jacobian of the transition model:
\begin{equation}\label{equation:04.01_EK:eqjacobi}
\begin{split}A_d[k] = I + h \left. \frac{\partial f \left(x[k],u[k] \right)}{\partial x[k]} \right|_{x[k]=\hat{x}[k]}\end{split}
\end{equation}
\sphinxAtStartPar
This part and the fact that the nonlinear transition model is used directly as the predictor are the extensions part of the EKF compared to the linear KF.

\sphinxAtStartPar
The output from the filter are the estimated states: \(\hat{x}\) and estimated state covariance matrix \(\hat{P}\). \(\hat{x}\) represent the most likely estimates, but the estimates have uncertainty that are expressed in \(\hat{P}\).

\sphinxAtStartPar
The state of the system is descrived by the ships position, heading, velocities and yaw velocity:
\begin{equation}\label{equation:04.01_EK:eqstates}
\begin{split}x = [x_0,y_0,\psi,u,v,r]^T\end{split}
\end{equation}
\sphinxAtStartPar
The initial state \(x_0\) is taken as the mean value of the first five measurements, where the velocities are estimated with numeric differentiation.

\sphinxAtStartPar
\(C_d\) selects the measured states (\(x_0\), \(y_0\), \(\psi\)):
\begin{equation}\label{equation:04.01_EK:eqcd}
\begin{split}\displaystyle C_{d} = h \left[\begin{matrix}1 & 0 & 0 & 0 & 0 & 0\\0 & 1 & 0 & 0 & 0 & 0\\0 & 0 & 1 & 0 & 0 & 0\end{matrix}\right]\end{split}
\end{equation}
\sphinxAtStartPar
\(E_d\) selects the hidden states (\(u\), \(v, \)r\$):
\begin{equation}\label{equation:04.01_EK:eqed}
\begin{split}\displaystyle E_{d} = h \left[\begin{matrix}0 & 0 & 0\\0 & 0 & 0\\0 & 0 & 0\\1 & 0 & 0\\0 & 1 & 0\\0 & 0 & 1\end{matrix}\right]\end{split}
\end{equation}
\sphinxAtStartPar
Where \(h\) is the discrete time step.

\sphinxAtStartPar
\(R_d\) describes the covariance matrix of the measurement, \(Q_d\) is the covariance matrix of the process model. \(P_0\) is the initial state covariance.
Selecting good values for these three matrixes is the tricky part in getting the EKF to work well. The amount of expected measurement noise in the data should be inserted in to \(R_d\) and the amount of error generated by the process model (VMM) needs to be estimated in \(Q_d\). So the choices for these matrixes very much depend on the beleif in the present data and the present process model.


\subsubsection{RTS smoother}
\label{\detokenize{04.01_EK:rts-smoother}}\label{\detokenize{04.01_EK:rts}}
\sphinxAtStartPar
EKF only uses the previous time step to make a prediction. This property is very convenient when used in online applications, where new data arrives contineously, for instance in auto pilots. The drawback is however that the filter is not allowed to look at future time steps. For the PIT on already existing data, this is an uneccessary restriction. An EKF filter can be allowed to include future time steps in the filtering by adding a smoother after the filter. The PIT uses a RTS smoother (Rauch et al., 1965) which is an algorithm that runs the EKF backwards to also acount for future time steps.

\sphinxAtStartPar
The EKF and RTS have been run on simulated data with Gausian noise added, to see if the real states can be identified. Results from this can be seen in  {\hyperref[\detokenize{04.01_EK:fig-ekf}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}. It can be seen that the EKF can identify the heading and yaw rate well, but the yaw acceleration, being the higher order state is still noisy. The RTS smoother is needed to also get an accurate estimate of the yaw acceleration.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{3baf8629fbc5db61dec7096adfafe1b56edd92fa9c8c699e1aa82e4970612980}.png}
\caption{EKF and RTS on simulated data (real) with Gausian noise added (raw).}\label{\detokenize{04.01_EK:fig-ekf}}\end{figure}


\section{Test cases}
\label{\detokenize{05.01_model_tests:test-cases}}\label{\detokenize{05.01_model_tests::doc}}
\sphinxAtStartPar
Parameters in Abkowitz VMM:s are identified with the developed PIT for three test cases: WPCC, LNG and KVLCC2. Model test data from SSPA Maritime Dynamics Laboratory is used for WPCC, and LNG. Data from the SIMMAN2008 conference tested at HSVA is used for the KVLCC2. Main dimensions for the ship models used in these tests are summarized in {\hyperref[\detokenize{05.01_model_tests:ship-datas}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}.

\begin{figure}[htbp]
\centering
\capstart

\begin{sphinxVerbatim}[commandchars=\\\{\}]
               T [m]  L [m]    CB  B [m]  LCG [m]   m [kg]  Izz [kg m2]  \PYGZbs{}
WPCC            0.21   5.01  0.45   0.95     0.00   441.03       693.12   
LNG             0.21   5.15  0.77   0.84    \PYGZhy{}0.05   715.46      1000.36   
KVLCC2 (HSVA)   0.46   7.00  0.81   1.27     0.24  3272.00      9908.58   

               Disp [m3]  scale factor  Np  
WPCC                0.44          41.2   2  
LNG                 0.72          55.0   2  
KVLCC2 (HSVA)       3.27          45.7   1  
\end{sphinxVerbatim}
\caption{Ship data in model scale for WPCC, LNG tanker and KVLCC2.}\label{\detokenize{05.01_model_tests:ship-datas}}\end{figure}


\subsection{Initial guessed parameters}
\label{\detokenize{05.01_model_tests:initial-guessed-parameters}}
\sphinxAtStartPar
Following the PIT algorithm ({\hyperref[\detokenize{01.01_method:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}) first step is to make an initial guess for a linear VMM to be used in the the first EKF iteration.
The following semi\sphinxhyphen{}empirical formulas are used as initial guesses for hydrodynamic derivatives.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameter
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Equation
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Reference
\\
\hline
\sphinxAtStartPar
\(N_{r}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(\frac{0.039 B}{T} - \frac{0.56 B}{L} + 0.25\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(N_{\dot{r}}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(\frac{0.017 B CB}{T} - \frac{0.33 B}{L} + 0.0833333333333333\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(N_{v}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(0.5 + \frac{2.4 T}{L}\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(N_{\dot{v}}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(- \frac{0.04 B}{T} + \frac{1.1 B}{L}\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(X_{\dot{u}}\)
&
\sphinxAtStartPar
\(\displaystyle \frac{2.0 m}{L^{3} \rho \left(\pi \sqrt{\frac{L^{3}}{volume}} - 14\right)}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(Y_{r}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(- \frac{0.08 B}{T} + \frac{2.2 B}{L} - 0.5\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(Y_{\dot{r}}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(- \frac{0.0033 B^{2}}{T^{2}} + \frac{0.67 B}{L}\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(Y_{v}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(\frac{0.4 B CB}{T} + 1\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\sphinxAtStartPar
\(Y_{\dot{v}}\)
&
\sphinxAtStartPar
\(\displaystyle - \frac{\pi T^{2} \left(- \frac{5.1 B^{2}}{L^{2}} + \frac{0.16 B CB}{T} + 1\right)}{L^{2}}\)
&
\sphinxAtStartPar
{[}\hyperlink{cite.bibligraphy:id163}{Bri93}{]}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Calculated values for the three test cases can be seen in {\hyperref[\detokenize{05.01_model_tests:initial-parameters}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}

\begin{figure}[htbp]
\centering
\capstart

\begin{sphinxVerbatim}[commandchars=\\\{\}]
               Ndelta     Nr  Nrdot     Nv  Nvdot  Xudot  Ydelta     Yr  \PYGZbs{}
WPCC             \PYGZhy{}1.5 \PYGZhy{}1.719 \PYGZhy{}0.299 \PYGZhy{}3.184 \PYGZhy{}0.128  0.179     3.0  2.402   
LNG              \PYGZhy{}1.5 \PYGZhy{}1.675 \PYGZhy{}0.436 \PYGZhy{}3.205 \PYGZhy{}0.115  0.355     3.0  2.446   
KVLCC2 (HSVA)    \PYGZhy{}1.5 \PYGZhy{}3.415 \PYGZhy{}0.822 \PYGZhy{}8.707 \PYGZhy{}1.166  1.050     3.0  4.305   

               Yrdot      Yv   Yvdot  
WPCC          \PYGZhy{}0.303  \PYGZhy{}9.713  \PYGZhy{}6.109  
LNG           \PYGZhy{}0.309 \PYGZhy{}11.916  \PYGZhy{}7.246  
KVLCC2 (HSVA) \PYGZhy{}1.271 \PYGZhy{}25.266 \PYGZhy{}15.846  
\end{sphinxVerbatim}
\caption{Initial guess for linear hydrodynamic derivatives for WPCC, LNG tanker and KVLCC2. (Values have been multiplied by 1000)}\label{\detokenize{05.01_model_tests:initial-parameters}}\end{figure}


\subsection{Motion regression}
\label{\detokenize{05.01_model_tests:motion-regression}}
\sphinxAtStartPar
Hydrodynamic deriviatives in the Abkowitz model are identified with linear regression on forces and moments from the model tests inverse dynamics. A comparison between the inverse dynamic forces and prediction with the regressed model is shown for one of the KVLCC2 model tests in {\hyperref[\detokenize{05.01_model_tests:force-prediction}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{558fe8b4f63a7ea8867729f4269e8653f60838b482aa69a273c55c1ef798e94f}.png}
\caption{Forces and moment from model test inverse dynamics and prediction with the regressed model.}\label{\detokenize{05.01_model_tests:force-prediction}}\end{figure}


\subsection{Iterations}
\label{\detokenize{05.01_model_tests:iterations}}
\sphinxAtStartPar
Simulation results with the initial guessed model and two iterrations of the PIT algorithm is shown in {\hyperref[\detokenize{05.01_model_tests:id10}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}.
It can be seen that the first iteration of the PIT algorithm is much closer to the model test data compared to the initial guessed linear VMM model and the second iteration is even closer. The motion regression in the PIT algorithm has been run on all of the KVLCC2 model tests.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{520a53a226a0bc064ec1cf2e0c1fdf3d2e5c7853b497bdb5e864735575335fb1}.png}
\caption{Model test data for one of the KVLCC2 tests compared to simulations with initial model, PIT first iteration model and PIT second iteration model.}\label{\detokenize{05.01_model_tests:id10}}\end{figure}


\subsection{Simulations}
\label{\detokenize{05.01_model_tests:simulations}}
\sphinxAtStartPar
Comparisons of model test and corresponding simulations with identified Abkowitz model can be seen for three test cases in {\hyperref[\detokenize{05.01_model_tests:wpcc}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}, {\hyperref[\detokenize{05.01_model_tests:lng}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}} and {\hyperref[\detokenize{05.01_model_tests:kvlcc2-hsva}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2dde62e4151043c2d46a1b862cf16867ab060fe081ebe08d0caa1143814d672f}.png}
\caption{Comparison of model tests and simulations with identified Abkowitz model for WPCC.}\label{\detokenize{05.01_model_tests:wpcc}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{e7acf9ff2285f3db4cd05114a6580446cf1471913ba936fce3e18388657918b6}.png}
\caption{Comparison of model tests and simulations with identified Abkowitz model for LNG.}\label{\detokenize{05.01_model_tests:lng}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{7d8c1713f41b735373139926904633fafde2347c853431e8bf260ef95c11d5e7}.png}
\caption{Comparison of model tests and simulations with identified Abkowitz model for KVLCC2.}\label{\detokenize{05.01_model_tests:kvlcc2-hsva}}\end{figure}


\subsection{Multicollinearity}
\label{\detokenize{05.01_model_tests:multicollinearity}}
\sphinxAtStartPar
The printout from the OLS Regression results for Abkowitz fy\sphinxhyphen{}equation for KVLCC2 data is shown in {\hyperref[\detokenize{05.01_model_tests:regression-abkowitz-summary}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}. The printout shows the regressed parameters (coef) together with, standard deviation (std err) and confidence intervals ({[}0.025 	0.975{]}). The P\sphinxhyphen{}values from hypothesis tests (P>|t|) is very high for some of the parameters such as: \(Y_{\delta}\), \(Y_r\) etc. This is indicating that the model has too many parameters for the present dataset. Strong multicollinearity is also reported which is a known problem for the the VMM:s {[}\hyperlink{cite.bibligraphy:id150}{LGSZ16}{]}, {[}\hyperlink{cite.bibligraphy:id180}{WZ18}{]}. The coefficients which are found do not
have to be physically correct, but mathematically correct {[}\hyperlink{cite.bibligraphy:id204}{ITT08}{]} which is also something that is shown here, where some of the parameters have very large values (in the order of 10\textasciicircum{}8). This means that the regressed Abkowitz model for KVLCC2 does a very good job in describing the known data, that we see here, but will not work very well when extrapolating outside the known data, when making predictions.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{8f8f584b3cd234c16c9d301b620fc9e263a6c1c48f30d7265bb8690049fe7053}.png}
\caption{Regression result for Abkowitz model fy equation on KVLCC2 data.}\label{\detokenize{05.01_model_tests:regression-abkowitz-summary}}\end{figure}

\sphinxAtStartPar
Printout from an OLS Regression for a simplified Abkowitz fy\sphinxhyphen{}equation for KVLCC2 data is shown in {\hyperref[\detokenize{05.01_model_tests:regression-simple-summary}]{\sphinxcrossref{\DUrole{std,std-ref}{fig}}}}. This model has almost as high accuracy as the full Abkowitz model when comparing the R\textasciicircum{}2 values (0.996 compared to 0.993). The coefficients in this model also have much smaller values and smaller P\sphinxhyphen{}values. So this means that the simplified model describes the known data almost as good as the full Abkowitz model, but will most likely work better when making predictions outside the known data.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{f1df18924986121a37d48c9f4e6c24946b518c61e8446d206b236b510ef9c99b}.png}
\caption{Regression result for simplified Abkowitz model fy equation on KVLCC2 data.}\label{\detokenize{05.01_model_tests:regression-simple-summary}}\end{figure}


\section{Conclusions}
\label{\detokenize{10.00_conclusions:conclusions}}\label{\detokenize{10.00_conclusions::doc}}

\section{Bibliography}
\label{\detokenize{bibligraphy:bibliography}}\label{\detokenize{bibligraphy::doc}}
\sphinxAtStartPar



\section{Vessel Manoeuvring Models}
\label{\detokenize{appendix_vmms:vessel-manoeuvring-models}}\label{\detokenize{appendix_vmms::doc}}

\subsection{vmm\_abkowitz}
\label{\detokenize{appendix_vmms:vmm-abkowitz}}\begin{equation}\label{equation:appendix_vmms:eq_X_D_vmm_abkowitz}
\begin{split}
\begin{align*}
\operatorname{X_{D}}{\left(u,v,r,\delta,T \right)} = & X_{\delta\delta} \delta^{2} + X_{r\delta} \delta r + X_{rr} r^{2} + X_{T} T + X_{u\delta\delta} \delta^{2} u + X_{ur\delta} \delta r u \\
& + X_{urr} r^{2} u + X_{uuu} u^{3} + X_{uu} u^{2} + X_{uv\delta} \delta u v + X_{uvr} r u v + X_{uvv} u v^{2} \\
& + X_{u} u + X_{v\delta} \delta v + X_{vr} r v + X_{vv} v^{2} 
\end{align*}
\end{split}
\end{equation}\begin{equation}\label{equation:appendix_vmms:eq_Y_D_vmm_abkowitz}
\begin{split}
\begin{align*}
\operatorname{Y_{D}}{\left(u,v,r,\delta,T \right)} = & Y_{0uu} u^{2} + Y_{0u} u + Y_{0} + Y_{\delta\delta\delta} \delta^{3} + Y_{\delta} \delta + Y_{r\delta\delta} \delta^{2} r \\
& + Y_{rr\delta} \delta r^{2} + Y_{rrr} r^{3} + Y_{r} r + Y_{u\delta} \delta u + Y_{ur} r u + Y_{uu\delta} \delta u^{2} \\
& + Y_{uur} r u^{2} + Y_{uuv} u^{2} v + Y_{uv} u v + Y_{v\delta\delta} \delta^{2} v + Y_{vr\delta} \delta r v + Y_{vrr} r^{2} v \\
& + Y_{vv\delta} \delta v^{2} + Y_{vvr} r v^{2} + Y_{vvv} v^{3} + Y_{v} v 
\end{align*}
\end{split}
\end{equation}\begin{equation}\label{equation:appendix_vmms:eq_N_D_vmm_abkowitz}
\begin{split}
\begin{align*}
\operatorname{N_{D}}{\left(u,v,r,\delta,T \right)} = & N_{0uu} u^{2} + N_{0u} u + N_{0} + N_{\delta\delta\delta} \delta^{3} + N_{\delta} \delta + N_{r\delta\delta} \delta^{2} r \\
& + N_{rr\delta} \delta r^{2} + N_{rrr} r^{3} + N_{r} r + N_{T} T + N_{u\delta} \delta u + N_{ur} r u \\
& + N_{uu\delta} \delta u^{2} + N_{uur} r u^{2} + N_{uuv} u^{2} v + N_{uv} u v + N_{v\delta\delta} \delta^{2} v + N_{vr\delta} \delta r v \\
& + N_{vrr} r^{2} v + N_{vv\delta} \delta v^{2} + N_{vvr} r v^{2} + N_{vvv} v^{3} + N_{v} v 
\end{align*}
\end{split}
\end{equation}

\subsection{vmm\_linear}
\label{\detokenize{appendix_vmms:vmm-linear}}\begin{equation}\label{equation:appendix_vmms:eq_X_D_vmm_linear}
\begin{split}
\begin{align*}
\operatorname{X_{D}}{\left(u,v,r,\delta,T \right)} = & X_{\delta} \delta + X_{r} r + X_{u} u + X_{v} v 
\end{align*}
\end{split}
\end{equation}\begin{equation}\label{equation:appendix_vmms:eq_Y_D_vmm_linear}
\begin{split}
\begin{align*}
\operatorname{Y_{D}}{\left(u,v,r,\delta,T \right)} = & Y_{\delta} \delta + Y_{r} r + Y_{u} u + Y_{v} v 
\end{align*}
\end{split}
\end{equation}\begin{equation}\label{equation:appendix_vmms:eq_N_D_vmm_linear}
\begin{split}
\begin{align*}
\operatorname{N_{D}}{\left(u,v,r,\delta,T \right)} = & N_{\delta} \delta + N_{r} r + N_{u} u + N_{v} v 
\end{align*}
\end{split}
\end{equation}

\subsection{vmm\_martins\_simple}
\label{\detokenize{appendix_vmms:vmm-martins-simple}}\begin{equation}\label{equation:appendix_vmms:eq_X_D_vmm_martins_simple}
\begin{split}
\begin{align*}
\operatorname{X_{D}}{\left(u,v,r,\delta,T \right)} = & X_{\delta\delta} \delta^{2} + X_{rr} r^{2} + X_{T} T + X_{u} u + X_{vr} r v 
\end{align*}
\end{split}
\end{equation}\begin{equation}\label{equation:appendix_vmms:eq_Y_D_vmm_martins_simple}
\begin{split}
\begin{align*}
\operatorname{Y_{D}}{\left(u,v,r,\delta,T \right)} = & Y_{\delta} \delta + Y_{r} r + Y_{T\delta} \delta T + Y_{ur} r u + Y_{u} u + Y_{v} v 
\end{align*}
\end{split}
\end{equation}\begin{equation}\label{equation:appendix_vmms:eq_N_D_vmm_martins_simple}
\begin{split}
\begin{align*}
\operatorname{N_{D}}{\left(u,v,r,\delta,T \right)} = & N_{\delta} \delta + N_{r} r + N_{T\delta} \delta T + N_{T} T + N_{ur} r u + N_{u} u \\
& + N_{v} v 
\end{align*}
\end{split}
\end{equation}
\begin{sphinxthebibliography}{LGSZ16}
\bibitem[Abk64]{bibligraphy:id139}
\sphinxAtStartPar
M. A. Abkowitz. Ship hydrodynamics \sphinxhyphen{} steering and manoeuvrability. \sphinxstyleemphasis{Hydro\sphinxhyphen{} and Aerodynamics Laboratory, Hydrodynamics Section, Lyngby, Denmark, Report No. Hy\sphinxhyphen{}5, Lectures}, 1964. URL: \sphinxurl{https://repository.tudelft.nl/islandora/object/uuid\%3Ad511bd6b-ca2e-4f10-ad9f-6c881eb1e9f8} (visited on 2020\sphinxhyphen{}08\sphinxhyphen{}24).
\bibitem[Bri93]{bibligraphy:id163}
\sphinxAtStartPar
Jochim E. Brix. \sphinxstyleemphasis{Manoeuvring Technical Manual}. Seehafen\sphinxhyphen{}Verlag, 1993. ISBN 978\sphinxhyphen{}3\sphinxhyphen{}87743\sphinxhyphen{}902\sphinxhyphen{}9. Google\sphinxhyphen{}Books\sphinxhyphen{}ID: CMJ1NAAACAAJ.
\bibitem[Fos21]{bibligraphy:id167}
\sphinxAtStartPar
Thor I. Fossen. \sphinxstyleemphasis{Handbook of Marine Craft Hydrodynamics and Motion Control}. Wiley, 2nd edition edition, April 2021.
\bibitem[ITT08]{bibligraphy:id204}
\sphinxAtStartPar
ITTC. The Maneuvering Committee of ITTC, Final report and recommendations to the 25th ITTC, in Proceedings of the 25th International Towing Tank Conference. 2008.
\bibitem[LGSZ16]{bibligraphy:id150}
\sphinxAtStartPar
Weilin Luo, C. Guedes Soares, and Zaojian Zou. Parameter Identification of Ship Maneuvering Model Based on Support Vector Machines and Particle Swarm Optimization. \sphinxstyleemphasis{Journal of Offshore Mechanics and Arctic Engineering}, 138(3):031101, June 2016. URL: \sphinxurl{https://asmedigitalcollection.asme.org/offshoremechanics/article/doi/10.1115/1.4032892/376874/Parameter-Identification-of-Ship-Maneuvering-Model} (visited on 2020\sphinxhyphen{}08\sphinxhyphen{}24), \sphinxhref{https://doi.org/10.1115/1.4032892}{doi:10.1115/1.4032892}.
\bibitem[Nor60]{bibligraphy:id126}
\sphinxAtStartPar
\sphinxstylestrong{missing publisher in norrbin\_study\_1960}
\bibitem[WZ18]{bibligraphy:id180}
\sphinxAtStartPar
\sphinxstylestrong{missing publisher in wang\_quantifying\_2018}
\end{sphinxthebibliography}






\renewcommand{\indexname}{Proof Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{ek\sphinxhyphen{}algorithm}
\item\relax\sphinxstyleindexentry{ek\sphinxhyphen{}algorithm}\sphinxstyleindexextra{04.01\_EK}\sphinxstyleindexpageref{04.01_EK:\detokenize{ek-algorithm}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}

\end{document}